var SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
var CustomVerifier = artifacts.require('CustomVerifier');
var proof = require('../../zokrates/code/square/proof.json');

contract('TestSolnSquareVerifier', accounts => {
    const accountOne = accounts[0];
    const accountTwo = accounts[1];

    it('Test if a new solution can be added for contract - SolnSquareVerifier', async function () {

    	// verifier generated by zokrates
        const customVerifier = await CustomVerifier.new({ from: accountOne });
        //  SolnSquareVerifier contract
        const solnSquareVerifier = await SolnSquareVerifier.new(customVerifier.address, { from: accountOne });

    	const {a, b, c} = proof.proof;

        bytes32 solutionKey = keccak256(abi.encodePacked(a, b, c, input));

        let addedSolution = await solnSquareVerifier.addSolutionToArray(accountTwo, 1, solutionKey);

        assert.equal(addedSolution.logs[0].event, "SolutionAdded", "Could not add a solution.");
    })

    it('Test if an ERC721 token can be minted for contract - SolnSquareVerifier', async function () {

    	// verifier generated by zokrates
        const customVerifier = await CustomVerifier.new({ from: accountOne });

        //  SolnSquareVerifier contract
        const solnSquareVerifier = await SolnSquareVerifier.new(customVerifier.address, { from: accountOne });

    	const {a, b, c} = proof.proof;

        let mintingSucceded = await solnSquareVerifier.mint(accountTwo, 1, a, b, c, proof.inputs, { from: accountOne });

        assert(mintingSucceded, "Could not mint the token.");
    })
})
